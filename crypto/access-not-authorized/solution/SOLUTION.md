**Idea**: This challenge is a very textbook length extension attack inspired by the Flickr API debacle (https://vnhacker.blogspot.com/2009/09/flickrs-api-signature-forgery.html) and the corresponding cryptopals challenge (https://cryptopals.com/sets/4/challenges/29). The participants start with a valid message and its Message Authentication Code (MAC). Examination of the source code shows that it computes the mac with RIPEMD-160(secret_key||message). RIPEMD is vulnerable to length extension attacks. Therefore, the goal is to extend the starting message to contain the string ";verified=true" and forge a valid MAC for the new message.

**Theory**: RIPEMD160 computes a digest block by block, a block being 64 bytes. Internally it uses five registers set to magic values initially and updated during the block compression. The digest produced is the state of the registers after the compression of the last block. Intuitively, it is easy to understand that if one takes this digest and initialises the registers with it, the computation can continue, and more blocks be absorbed. We can then extend the initial message (without knowing the secret key) with our string ";verified=true" and compute the mac. There is, however, one problem to solve: the padding. RIPEMD160 fills the last block with padding if it is not exactly 64 bytes. This padding is a 1, followed by zeros until the block is 56 bytes, then the last 8 bytes contain the total length of the message (in bits) to hash. It is the same padding as MD4, which has some funky endianness to make it absurd (little-endian bytes, big-endian bits). The final crafted message will then look like message||padding-of-first-message||added-string.

**Practice**: Basically, there are two different tasks, crafting the message and computing its mac. For crafting the message, I give an example in message_forgery.py. It is simply about following the RFC carefully (endianness is a common mistake to look for) and not forgetting the length of the secret (indicated in a comment in the main.py file) in the total length that goes in the padding. For computing the mac, I recommend looking for an implementation of RIPEMD160 on the internet in your language of choice. Two things need to be tweaked, initialising the registers with the mac given in the challenge and changing the final length in the padding to include the first block (secret + message + padding) length. I give an example in python in mac_forgery.py with the comments starting by "ATTACK" indicating what it tweaked in the implementation.